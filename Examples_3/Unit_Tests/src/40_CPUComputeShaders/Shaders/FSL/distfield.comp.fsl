#include "fsl_ext.h"
#include "resources.h.fsl"

RES(Buffer(float), gInputBuffer, UPDATE_FREQ_NONE, t0, binding = 0);
RES(RWBuffer(float), gOutput, UPDATE_FREQ_NONE, u0, binding = 1);

STRUCT(DistanceFieldParams) {
    DATA(uint, width, None);     
    DATA(uint, height, None);    
    DATA(float, maxDistance, None);
    DATA(float, padding, None);  
};
RES(CBUFFER(DistanceFieldParams), gParams, UPDATE_FREQ_NONE, b0, binding = 2);

// Check if a pixel location contains a surface boundary 
bool IsSurfaceBoundary(uint2 pos)
{
    uint index = pos.y * gParams.width + pos.x;
    float center = gInputBuffer[index];
    
    if (abs(center - 0.5) > 0.5)
        return false;
        
    for (int dy = -1; dy <= 1; dy++)
    {
        for (int dx = -1; dx <= 1; dx++)
        {
            if (dx == 0 && dy == 0) continue;
            
            uint2 npos = uint2(
                clamp(int(pos.x) + dx, 0, int(gParams.width) - 1),
                clamp(int(pos.y) + dy, 0, int(gParams.height) - 1)
            );
            
            uint nindex = npos.y * gParams.width + npos.x;
            float neighbor = gInputBuffer[nindex];
            
            if ((center < 0.5 && neighbor >= 0.5) || (center >= 0.5 && neighbor < 0.5))
                return true;
        }
    }
    
    return false;
}

// Compute distance between two pixel positions
float ComputePointDistance(float2 p1, float2 p2)
{
    float2 diff = p2 - p1;
    return length(diff);
}

// Find distance to nearest boundary within search radius
float FindNearestBoundaryDistance(uint2 pos, int searchRadius)
{
    float2 pixelPos = float2(pos);
    float minDist = gParams.maxDistance;
    
    int xStart = max(0, int(pos.x) - searchRadius);
    int xEnd = min(int(gParams.width), int(pos.x) + searchRadius + 1);
    int yStart = max(0, int(pos.y) - searchRadius);
    int yEnd = min(int(gParams.height), int(pos.y) + searchRadius + 1);
    
    for (int y = yStart; y < yEnd; y++)
    {
        for (int x = xStart; x < xEnd; x++)
        {
            uint2 testPos = uint2(x, y);
            if (IsSurfaceBoundary(testPos))
            {
                float dist = ComputePointDistance(pixelPos, float2(testPos));
                minDist = min(minDist, dist);
            }
        }
    }
    
    return minDist;
}

NUM_THREADS(16, 16, 1)
void CS_MAIN(SV_DispatchThreadID(uint2) tid) 
{
    INIT_MAIN;
    
    if (tid.x >= gParams.width || tid.y >= gParams.height)
    {
        RETURN();
    }

    // Compute distance to nearest boundary
    float distance = FindNearestBoundaryDistance(tid, 16); // Search radius of 16 pixels
    
    // Determine sign based on input value
    uint index = tid.y * gParams.width + tid.x;
    float value = gInputBuffer[index];
    float sign = value >= 0.5 ? -1.0 : 1.0;
    
    // Write final signed distance
    gOutput[index] = sign * distance;

    RETURN();
}