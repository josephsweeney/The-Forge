#include "fsl_ext.h"
#include "resources.h.fsl"

RES(Buffer(float), gInputBuffer, UPDATE_FREQ_NONE, t0, binding = 0);
RES(RWBuffer(float), gOutputBuffer, UPDATE_FREQ_NONE, u0, binding = 1);
RES(RWBuffer(uint), gBoundaryBuffer, UPDATE_FREQ_NONE, u1, binding = 2);

STRUCT(DistanceFieldParams) {
    DATA(uint, width, None);     
    DATA(uint, height, None);    
    DATA(float, maxDistance, None);
    DATA(float, padding, None);  
};
RES(CBUFFER(DistanceFieldParams), gParams, UPDATE_FREQ_NONE, b0, binding = 2);

bool IsSurfaceBoundary(uint2 pos, uint index)
{
    float center = gInputBuffer[index];
    
    if (abs(center - 0.5) > 0.5)
    {
        gBoundaryBuffer[index] = 0;
        return false;
    }
        
    for (int dy = -1; dy <= 1; dy++)
    {
        for (int dx = -1; dx <= 1; dx++)
        {
            if (dx == 0 && dy == 0) continue;
            
            uint2 npos = uint2(
                clamp(int(pos.x) + dx, 0, int(gParams.width) - 1),
                clamp(int(pos.y) + dy, 0, int(gParams.height) - 1)
            );
            
            uint nindex = npos.y * gParams.width + npos.x;
            float neighbor = gInputBuffer[nindex];
            
            if ((center < 0.5 && neighbor >= 0.5) || (center >= 0.5 && neighbor < 0.5))
            {
                gBoundaryBuffer[index] = 1;
                return true;
            }
        }
    }
    
    gBoundaryBuffer[index] = 0;
    return false;
}

// Compute distance between two pixel positions
float ComputePointDistance(float2 p1, float2 p2)
{
    float2 diff = p2 - p1;
    return length(diff);
}

float FindNearestBoundaryDistance(uint2 pos, int searchRadius)
{
    float2 pixelPos = float2(pos);
    float minDist = gParams.maxDistance;
    
    int xStart = max(0, int(pos.x) - searchRadius);
    int xEnd = min(int(gParams.width), int(pos.x) + searchRadius + 1);
    int yStart = max(0, int(pos.y) - searchRadius);
    int yEnd = min(int(gParams.height), int(pos.y) + searchRadius + 1);
    
    for (int y = yStart; y < yEnd; y++)
    {
        for (int x = xStart; x < xEnd; x++)
        {
            uint testIndex = y * gParams.width + x;
            // Use boundary buffer instead of recomputing
            if (gBoundaryBuffer[testIndex] != 0)
            {
                float2 testPos = float2(x, y);
                float dist = length(testPos - pixelPos);
                minDist = min(minDist, dist);
            }
        }
    }
    
    return minDist;
}

NUM_THREADS(16, 16, 1)
void CS_MAIN(SV_DispatchThreadID(uint2) tid) 
{
    INIT_MAIN;
    
    if (tid.x >= gParams.width || tid.y >= gParams.height)
    {
        RETURN();
    }

    uint index = tid.y * gParams.width + tid.x;
    
    // First check and store boundary status
    IsSurfaceBoundary(tid, index);
    
    // Now compute distance using boundary buffer
    float distance = FindNearestBoundaryDistance(tid, 16);
    
    float value = gInputBuffer[index];
    float sign = value >= 0.5 ? -1.0 : 1.0;
    
    gOutputBuffer[index] = sign * distance;

    RETURN();
}